---% language=us engine=luatex runpath=texruns:manuals/luatex
---
---\environment luatex-style
---
---\startcomponent luatex-nodes
---
---# Nodes
---
---# *Lua* node representation[library=node]
---
---*TeX*'s nodes are represented in *Lua* as userdata objects with a variable set of
---fields. In the following syntax tables, such as the type of such a userdata object
---is represented as `<node>`.
---
---The current return value of `node.types()` is:
---\startluacode
---    for id, name in table.sortedhash(node.types()) do
---        context.type(name)
---        context(" (%s), ",id)
---    end
---    context.removeunwantedspaces()
---    context.removepunctuation()
---\stopluacode
---. % period
---
---The `lastnodetype` primitive is \ETEX\ compliant. The valid range is still
---`[-1,15]` and glyph nodes (formerly known as char nodes) have number 0 while
---ligature nodes are mapped to 7. That way macro packages can use the same symbolic
---names as in traditional \ETEX. Keep in mind that these \ETEX\ node numbers are
---different from the real internal ones and that there are more \ETEX\ node types
---than 15.
---
---You can ask for a list of fields with `node.fields` and for valid subtypes
---with `node.subtypes`. The `node.values` function reports some used
---values. Valid arguments are `dir`, `direction`, `glue`, `pdf_literal`, `pdf_action`, `pdf_window` and `color_stack`. Keep
---in mind that the setters normally expect a number, but this helper gives you a
---list of what numbers matter. For practical reason the `pagestate` values
---are also reported with this helper.
---
----------------------------------------------------------------


---
---# Main text nodes
---
---These are the nodes that comprise actual typesetting commands. A few fields are
---present in all nodes regardless of their type, these are:
---
--- field           type    explanation 
---
---@field next node    the next node # in a list, or nil 
---@field id number # the node's type (`id`) number 
---@field subtype number # the node `subtype` identifier 
---
---The `subtype` is sometimes just a dummy entry because not all nodes
---actually use the `subtype`, but this way you can be sure that all nodes
---accept it as a valid field name, and that is often handy in node list traversal.
---In the following tables `next` and `id` are not explicitly mentioned.
---
---Besides these three fields, almost all nodes also have an `attr` field, and
---there is a also a field called `prev`. That last field is always present,
---but only initialized on explicit request: when the function `node.slide()`
---is called, it will set up the `prev` fields to be a backwards pointer in
---the argument node list. By now most of *TeX*'s node processing makes sure that the
---`prev` nodes are valid but there can be exceptions, especially when the
---internal magic uses a leading `temp` nodes to temporarily store a state.
---
---# `hlist` nodes
---
--- field              type    explanation 
---
---@field subtype number # \showsubtypes{list} 
---@field attr node # list of attributes 
---@field width number # the width of the box 
---@field height number # the height of the box 
---@field depth number # the depth of the box 
---@field shift number # a displacement perpendicular to the character progression direction 
---@field glue_order number # a number in the range `[0,4]`, indicating the glue order 
---@field glue_set number # the calculated glue ratio 
---@field glue_sign number # 0 = `normal`, 1 = `stretching`, 2 = `shrinking` 
---@field head/list node    the first node # of the body of this list 
---@field dir string # the direction of this box, see \in [dirnodes] 
---
---A warning: never assign a node list to the `head` field unless you are sure
---its internal link structure is correct, otherwise an error may result.
---
---Note: the field name `head` and `list` are both valid. Sometimes it
---makes more sense to refer to a list by `head`, sometimes `list` makes
---more sense.
---
---# `vlist` nodes
---
---This node is similar to `hlist`, except that “shift” is a displacement
---perpendicular to the line progression direction, and “subtype” only has
---the values 0, 4, and 5.
---
---# `rule` nodes
---
---Contrary to traditional *TeX*, *LuaTeX* has more `rule` subtypes because we
---also use rules to store reuseable objects and images. User nodes are invisible
---and can be intercepted by a callback.
---
--- field             type    explanation 
---
---@field subtype number # \showsubtypes {rule} 
---@field attr node # list of attributes 
---@field width number # the width of the rule where the special value `-1073741824` is used for “running” glue dimensions 
---@field height number # the height of the rule (can be negative) 
---@field depth number # the depth of the rule (can be negative) 
---@field left number # shift at the left end (also subtracted from width) 
---@field right number # (subtracted from width) 
---@field dir string # the direction of this rule, see \in[dirnodes] 
---@field index number # an optional index that can be referred to 
---@field transform number # an private variable (also used to specify outline width) 
---
---The `left` and type {right} keys are somewhat special (and experimental).
---When rules are auto adapting to the surrounding box width you can enforce a shift
---to the right by setting `left`. The value is also subtracted from the width
---which can be a value set by the engine itself and is not entirely under user
---control. The `right` is also subtracted from the width. It all happens in
---the backend so these are not affecting the calculations in the frontend (actually
---the auto settings also happen in the backend). For a vertical rule `left`
---affects the height and `right` affects the depth. There is no matching
---interface at the *TeX* end (although we can have more keywords for rules it would
---complicate matters and introduce a speed penalty.) However, you can just
---construct a rule node with *Lua* and write it to the *TeX* input. The `outline` subtype is just a convenient variant and the `transform` field
---specifies the width of the outline.
---
---# `ins` nodes
---
---This node relates to the `insert` primitive.
---
--- field             type    explanation 
---
---@field subtype number # the insertion class 
---@field attr node # list of attributes 
---@field cost number # the penalty associated with this insert 
---@field height number # height of the insert 
---@field depth number # depth of the insert 
---@field head/list node    the first node # of the body of this insert 
---
---There is a set of extra fields that concern the associated glue: `width`,
---`stretch`, `stretch_order`, `shrink` and `shrink_order`.
---These are all numbers.
---
---A warning: never assign a node list to the `head` field unless you are sure
---its internal link structure is correct, otherwise an error may result. You can use
---`list` instead (often in functions you want to use local variable with similar
---names and both names are equally sensible).
---
---# `mark` nodes
---
---This one relates to the `mark` primitive.
---
--- field           type    explanation 
---
---@field subtype number # unused 
---@field attr node # list of attributes 
---@field class number # the mark class 
---@field mark table # a table representing a token list 
---
---# `adjust` nodes
---
---This node comes from `vadjust` primitive.
---
--- field             type    explanation 
---
---@field subtype number # \showsubtypes{adjust} 
---@field attr node # list of attributes 
---@field head/list node # adjusted material 
---
---A warning: never assign a node list to the `head` field unless you are sure
---its internal link structure is correct, otherwise an error may be the result.
---
---# `disc` nodes
---
---The `discretionary` and `-`, the `-` character but also the
---hyphenation mechanism produces these nodes.
---
--- field           type    explanation 
---
---@field subtype number # \showsubtypes{disc} 
---@field attr node # list of attributes 
---@field pre node # pointer to the pre-break text 
---@field post node # pointer to the post-break text 
---@field replace node # pointer to the no-break text 
---@field penalty number # the penalty associated with the break, normally `hyphenpenalty` or `exhyphenpenalty` 
---
---The subtype numbers 4 and 5 belong to the “of-f-ice” explanation given
---elsewhere. These disc nodes are kind of special as at some point they also keep
---information about breakpoints and nested ligatures.
---
---The `pre`, `post` and `replace` fields at the *Lua* end are in
---fact indirectly accessed and have a `prev` pointer that is not `nil`.
---This means that when you mess around with the head of these (three) lists, you
---also need to reassign them because that will restore the proper `prev`
---pointer, so:
---
---```
---pre = d.pre
----- change the list starting with pre
---d.pre = pre
---```
---
---Otherwise you can end up with an invalid internal perception of reality and
---*LuaTeX* might even decide to crash on you. It also means that running forward
---over for instance `pre` is ok but backward you need to stop at `pre`.
---And you definitely must not mess with the node that `prev` points to, if
---only because it is not really a node but part of the disc data structure (so
---freeing it again might crash *LuaTeX*).
---
---# `math` nodes
---
---Math nodes represent the boundaries of a math formula, normally wrapped into
---``` signs.
---
--- field            type    explanation 
---
---@field subtype number # \showsubtypes{math} 
---@field attr node # list of attributes 
---@field surround number # width of the `mathsurround` kern 
---
---There is a set of extra fields that concern the associated glue: `width`,
---`stretch`, `stretch_order`, `shrink` and `shrink_order`.
---These are all numbers.
---
---# `glue` nodes
---
---Skips are about the only type of data objects in traditional *TeX* that are not a
---simple value. They are inserted when *TeX* sees a space in the text flow but also
---by `hskip` and `vskip`. The structure that represents the glue
---components of a skip is called a `glue_spec`, and it has the following
---accessible fields:
---
--- field                 type    explanation 
---
---@field width number # the horizontal or vertical displacement 
---@field stretch number # extra (positive) displacement or stretch amount 
---@field stretch_order number # factor applied to stretch amount 
---@field shrink number # extra (negative) displacement or shrink amount
---@field shrink_order number # factor applied to shrink amount 
---
---The effective width of some glue subtypes depends on the stretch or shrink needed
---to make the encapsulating box fit its dimensions. For instance, in a paragraph
---lines normally have glue representing spaces and these stretch or shrink to make
---the content fit in the available space. The `effective_glue` function that
---takes a glue node and a parent (hlist or vlist) returns the effective width of
---that glue item. When you pass `true` as third argument the value will be
---rounded.
---
---A `glue_spec` node is a special kind of node that is used for storing a set
---of glue values in registers. Originally they were also used to store properties
---of glue nodes (using a system of reference counts) but we now keep these
---properties in the glue nodes themselves, which gives a cleaner interface to *Lua*.
---
---The indirect spec approach was in fact an optimization in the original *TeX*
---code. First of all it can save quite some memory because all these spaces that
---become glue now share the same specification (only the reference count is
---incremented), and zero testing is also a bit faster because only the pointer has
---to be checked (this is no longer true for engines that implement for instance
---protrusion where we really need to ensure that zero is zero when we test for
---bounds). Another side effect is that glue specifications are read-only, so in
---the end copies need to be made when they are used from *Lua* (each assignment to
---a field can result in a new copy). So in the end the advantages of sharing are
---not that high (and nowadays memory is less an issue, also given that a glue node
---is only a few memory words larger than a spec).
---
--- field           type    explanation 
---
---@field subtype number # \showsubtypes{glue} 
---@field attr node # list of attributes 
---@field leader node # pointer to a box or rule for leaders 
---
---In addition there are the `width`, `stretch` `stretch_order`,
---`shrink`, and `shrink_order` fields. Note that we use the key `width` in both horizontal and vertical glue. This suits the *TeX* internals well
---so we decided to stick to that naming.
---
---A regular word space also results in a `spaceskip` subtype (this used to be
---a `userskip` with subtype zero).
---
---# `kern` nodes
---
---The `kern` command creates such nodes but for instance the font and math
---machinery can also add them.
---
--- field           type    explanation 
---
---@field subtype number # \showsubtypes{kern} 
---@field attr node # list of attributes 
---@field kern number # fixed horizontal or vertical advance 
---
---# `penalty` nodes
---
---The `penalty` command is one that generates these nodes.
---
--- field           type    explanation 
---
---@field subtype number # \showsubtypes{penalty} 
---@field attr node # list of attributes 
---@field penalty number # the penalty value 
---
---The subtypes are just informative and *TeX* itself doesn't use them. When you
---run into an `linebreakpenalty` you need to keep in mind that it's a
---accumulation of `club`, `widow` and other relevant penalties.
---
---\subsection[glyphnodes]{`glyph` nodes}
---
---These are probably the mostly used nodes and although you can push them in the
---current list with for instance `char` *TeX* will normally do it for you when
---it considers some input to be text.
---
--- field                    type     explanation 
---
---@field subtype number # bit field 
---@field attr node # list of attributes 
---@field char number # the character index in the font 
---@field font number # the font identifier 
---@field lang number # the language identifier 
---@field left number # the frozen `\lefthyphenmnin` value 
---@field right number # the frozen `\righthyphenmnin` value 
---@field uchyph boolean # the frozen `uchyph` value 
---@field components node # pointer to ligature components 
---@field xoffset number # a virtual displacement in horizontal direction 
---@field yoffset number # a virtual displacement in vertical direction 
---@field width number # the (original) width of the character 
---@field height number # the (original) height of the character
---@field depth number # the (original) depth of the character
---@field expansion_factor number # the to be applied expansion_factor 
---@field data number # a general purpose field for users (we had room for it) 
---
---The `width`, `height` and `depth` values are read-only. The
---`expansion_factor` is assigned in the par builder and used in the backend.
---
---A warning: never assign a node list to the components field unless you are sure
---its internal link structure is correct, otherwise an error may be result. Valid
---bits for the `subtype` field are:
---
--- bit  meaning   
---
--- 0    character 
--- 1    ligature  
--- 2    ghost     
--- 3    left      
--- 4    right     
---
---See \in {section} [charsandglyphs] for a detailed description of the `subtype` field.
---
---The `expansion_factor` has been introduced as part of the separation
---between font- and backend. It is the result of extensive experiments with a more
---efficient implementation of expansion. Early versions of *LuaTeX* already
---replaced multiple instances of fonts in the backend by scaling but contrary to
---*PDF*TEX\ in *LuaTeX* we now also got rid of font copies in the frontend and
---replaced them by expansion factors that travel with glyph nodes. Apart from a
---cleaner approach this is also a step towards a better separation between front-
---and backend.
---
---The `is_char` function checks if a node is a glyph node with a subtype still
---less than 256. This function can be used to determine if applying font logic to a
---glyph node makes sense. The value `nil` gets returned when the node is not
---a glyph, a character number is returned if the node is still tagged as character
---and `false` gets returned otherwise. When nil is returned, the id is also
---returned. The `is_glyph` variant doesn't check for a subtype being less
---than 256, so it returns either the character value or nil plus the id. These
---helpers are not always faster than separate calls but they sometimes permit
---making more readable tests. The `uses_font` helpers takes a node
---and font id and returns true when a glyph or disc node references that font.
---
---# `boundary` nodes
---
---This node relates to the `noboundary`, `boundary`, `protrusionboundary` and `wordboundary` primitives.
---
--- field           type    explanation 
---
---@field subtype number # \showsubtypes{boundary} 
---@field attr node # list of attributes 
---@field value number # values 0--255 are reserved 
---
---# `local_par` nodes
---
---This node is inserted at the start of a paragraph. You should not mess
---too much with this one.
---
--- field                   type    explanation 
---
---@field attr node # list of attributes 
---@field pen_inter number # local interline penalty (from `localinterlinepenalty`) 
---@field pen_broken number # local broken penalty (from `localbrokenpenalty`) 
---@field dir string # the direction of this par. see \in [dirnodes] 
---@field box_left node # the `localleftbox` 
---@field box_left_width number # width of the `localleftbox` 
---@field box_right node # the `localrightbox` 
---@field box_right_width number # width of the `localrightbox` 
---
---A warning: never assign a node list to the `box_left` or `box_right`
---field unless you are sure its internal link structure is correct, otherwise an
---error may result.
---
---\subsection[dirnodes]{`dir` nodes}
---
---Direction nodes mark parts of the running text that need a change of direction and \
---the `textdir` command generates them.
---
--- field         type    explanation 
---
---@field attr node # list of attributes 
---@field dir string # the direction (but see below) 
---@field level number # nesting level of this direction whatsit 
---
---Direction specifiers are three-letter combinations of `T`, `B`,
---`R`, and `L`. These are built up out of three separate items:
---
---* the first  is the direction of the “top”   of paragraphs
---
---* the second is the direction of the “start” of lines
---
---* the third  is the direction of the “top”   of glyphs
---
---However, only four combinations are accepted: `TLT`, `TRT`, `RTT`, and `LTL`. Inside actual `dir` nodes, the representation of
---`dir` is not a three-letter but a combination of numbers. When printed the
---direction is indicated by a `+` or `-`, indicating whether the value
---is pushed or popped from the direction stack.
---
---# `marginkern` nodes
---
---Margin kerns result from protrusion.
---
--- field           type    explanation 
---
---@field subtype number # \showsubtypes{marginkern} 
---@field attr node # list of attributes 
---@field width number # the advance of the kern 
---@field glyph node # the glyph to be used 
---
----------------------------------------------------------------


---
---# Math noads
---
---These are the so||called “noad”s and the nodes that are specifically
---associated with math processing. Most of these nodes contain subnodes so that the
---list of possible fields is actually quite small. First, the subnodes:
---
---# Math kernel subnodes
---
---Many object fields in math mode are either simple characters in a specific family
---or math lists or node lists. There are four associated subnodes that represent
---these cases (in the following node descriptions these are indicated by the word
---`<kernel>`).
---
---The `next` and `prev` fields for these subnodes are unused.
---
---# `math_char` and `math_text_char` subnodes
---
--- field        type    explanation 
---
---@field attr node # list of attributes 
---@field char number # the character index 
---@field fam number # the family number 
---
---The `math_char` is the simplest subnode field, it contains the character
---and family for a single glyph object. The `math_text_char` is a special
---case that you will not normally encounter, it arises temporarily during math list
---conversion (its sole function is to suppress a following italic correction).
---
---# `sub_box` and `sub_mlist` subnodes
---
--- field             type  explanation 
---
---@field attr node # list of attributes 
---@field head/list node # list of nodes 
---
---These two subnode types are used for subsidiary list items. For `sub_box`,
---the `head` points to a “normal” vbox or hbox. For `sub_mlist`,
---the `head` points to a math list that is yet to be converted.
---
---A warning: never assign a node list to the `head` field unless you are sure
---its internal link structure is correct, otherwise an error is triggered.
---
---# `delim` subnodes
---
---There is a fifth subnode type that is used exclusively for delimiter fields. As
---before, the `next` and `prev` fields are unused.
---
--- field              type    explanation 
---
---@field attr node # list of attributes 
---@field small_char number # character index of base character 
---@field small_fam number # family number of base character 
---@field large_char number # character index of next larger character 
---@field large_fam number # family number of next larger character 
---
---The fields `large_char` and `large_fam` can be zero, in that case the
---font that is set for the `small_fam` is expected to provide the large
---version as an extension to the `small_char`.
---
---# Math core nodes
---
---First, there are the objects (the *TeX* book calls them “atoms”) that are
---associated with the simple math objects: ord, op, bin, rel, open, close, punct,
---inner, over, under, vcent. These all have the same fields, and they are combined
---into a single node type with separate subtypes for differentiation.
---
---Some noads have an option field. The values in this bitset are common:
---
--- meaning          bits                      
---
--- set                            `0x08` 
--- internal         `0x00` + `0x08` 
--- internal         `0x01` + `0x08` 
--- axis             `0x02` + `0x08` 
--- no axis          `0x04` + `0x08` 
--- exact            `0x10` + `0x08` 
--- left             `0x11` + `0x08` 
--- middle           `0x12` + `0x08` 
--- right            `0x14` + `0x08` 
--- no sub script    `0x21` + `0x08` 
--- no super script  `0x22` + `0x08` 
--- no script        `0x23` + `0x08` 
---
---# simple `noad` nodes
---
--- field           type         explanation 
---
---@field subtype number # \showsubtypes{noad} 
---@field attr node # list of attributes 
---@field nucleus kernel node # base 
---@field sub kernel node # subscript 
---@field sup kernel node # superscript 
---@field options number # bitset of rendering options 
---
---# `accent` nodes
---
--- field              type         explanation 
---
---@field subtype number # \showsubtypes{accent} 
---@field nucleus kernel node # base 
---@field sub kernel node # subscript 
---@field sup kernel node # superscript 
---@field accent kernel node # top accent 
---@field bot_accent kernel node # bottom accent 
---@field fraction number # larger step criterium (divided by 1000) 
---
---# `style` nodes
---
--- field         type    explanation    
---
---@field style string # contains the style 
---
---There are eight possibilities for the string value: one of `display`,
---`text`, `script`, or `scriptscript`. Each of these can have
---be prefixed by `cramped`.
---
---# `choice` nodes
---
--- field                type  explanation 
---
---@field attr node # list of attributes 
---@field display node # list of display size alternatives 
---@field text node # list of text size alternatives 
---@field script node # list of scriptsize alternatives 
---@field scriptscript node # list of scriptscriptsize alternatives 
---
---Warning: never assign a node list to the `display`, `text`, `script`, or `scriptscript` field unless you are sure its internal link
---structure is correct, otherwise an error can occur.
---
---# `radical` nodes
---
--- field           type            explanation 
---
---@field subtype number # \showsubtypes{radical} 
---@field attr node # list of attributes 
---@field nucleus kernel node # base 
---@field sub kernel node # subscript 
---@field sup kernel node # superscript 
---@field left delimiter node # 
---@field degree kernel node # only set by `Uroot` 
---@field width number # required width 
---@field options number # bitset of rendering options 
---
---Warning: never assign a node list to the `nucleus`, `sub`, `sup`, `left`, or `degree` field unless you are sure its internal
---link structure is correct, otherwise an error can be triggered.
---
---# `fraction` nodes
---
--- field           type            explanation 
---
---@field attr node # list of attributes 
---@field width number # (optional) width of the fraction 
---@field num kernel node # numerator 
---@field denom kernel node # denominator 
---@field left delimiter node # left side symbol 
---@field right delimiter node # right side symbol 
---@field middle delimiter node # middle symbol 
---@field options number # bitset of rendering options 
---
---Warning: never assign a node list to the `num`, or `denom` field
---unless you are sure its internal link structure is correct, otherwise an error
---can result.
---
---# `fence` nodes
---
--- field           type            explanation 
---
---@field subtype number # \showsubtypes{fence} 
---@field attr node # list of attributes 
---@field delim delimiter node # delimiter specification 
---@field italic number # italic correction 
---@field height number # required height 
---@field depth number # required depth 
---@field options number # bitset of rendering options 
---@field class number # spacing related class 
---
---Warning: some of these fields are used by the renderer and might get adapted in
---the process.
---
----------------------------------------------------------------


---
---# Front-end whatsits
---
---Whatsit nodes come in many subtypes that you can ask for them by running
---`node.whatsits`:
---\startluacode
---    for id, name in table.sortedpairs(node.whatsits()) do
---        context.type(name)
---        context(" (%s), ",id)
---    end
---    context.removeunwantedspaces()
---    context.removepunctuation()
---\stopluacode
---. % period
---
---Some of them are generic and independent of the output mode and others are
---specific to the chosen backend: \DVI\ or *PDF*. Here we discuss the generic
---font-end nodes nodes.
---
---# `open`
---
--- field          type    explanation 
---
---@field attr node # list of attributes 
---@field stream number # *TeX*'s stream id number 
---@field name string # file name 
---@field ext string # file extension 
---@field area string # file area (this may become obsolete) 
---
---# `write`
---
--- field          type    explanation 
---
---@field attr node # list of attributes 
---@field stream number # *TeX*'s stream id number 
---@field data string # a string representing the token list to be written 
---@field value table # a table representing the token list to be written 
---
---# `close`
---
--- field          type    explanation 
---
---@field attr node # list of attributes 
---@field stream number # *TeX*'s stream id number 
---
---# `user_defined`
---
---User-defined whatsit nodes can only be created and handled from *Lua* code. In
---effect, they are an extension to the extension mechanism. The *LuaTeX* engine
---will simply step over such whatsits without ever looking at the contents.
---
--- field           type    explanation 
---
---@field attr node # list of attributes 
---@field user_id number # id number 
---@field type number # type of the value 
---@field value number # a *Lua* number  node    a node list  string  a *Lua* string  table   a *Lua* table 
---
---The `type` can have one of six distinct values. The number is the \ASCII\
---value if the first character of the type name (so you can use string.byte("l")
---instead of `108`).
---
--- value  meaning  explanation 
---
---   97   a        list of attributes (a node list) 
---  100   d        a *Lua* number 
---  108   l        a *Lua* value (table, number, boolean, etc) 
---  110   n        a node list 
---  115   s        a *Lua* string 
---  116   t        a *Lua* token list in *Lua* table form (a list of triplets) 
---
---# `save_pos`
---
--- field        type  explanation 
---
---@field attr node # list of attributes 
---
---# `late_lua`
---
--- field         type                explanation 
---
---@field attr node # list of attributes 
---@field data string # or function  the to be written information stored as *Lua* value 
---@field token string # the to be written information stored as token list 
---@field name string # the name to use for *Lua* error reporting 
---
---The difference between `data` and `string` is that on assignment, the
---`data` field is converted to a token list, cf.\ use as `latelua`. The
---`string` version is treated as a literal string.
---
---When a function is used, it gets called with as first argument the node that triggers
---the call.
---
----------------------------------------------------------------


---
---# \DVI\ backend whatsits
---
---# `special`
---
---There is only one \DVI\ backend whatsit, and it just flushes its content to the
---output file.
---
--- field        type    explanation 
---
---@field attr node # list of attributes 
---@field data string # the `special` information 
---
----------------------------------------------------------------


---
---# *PDF* backend whatsits
---
---# `pdf_literal` and `pdf_late_literal`
---
--- field         type    explanation 
---
---@field attr node # list of attributes 
---@field mode number # the “mode” setting of this literal 
---@field data string # the to be written information stored as *Lua* string 
---@field token string # the to be written information stored as token list 
---
---Possible mode values are:
---
--- value  keyword        
---
--- 0      `origin`  
--- 1      `page`    
--- 2      `direct`  
--- 3      `raw`     
--- 4      `text`    
---
---The higher the number, the less checking and the more you can run into trouble.
---Especially the `raw` variant can produce bad *PDF* so you can best check
---what you generate.
---
---# `pdf_refobj`
---
--- field          type    explanation 
---
---@field attr node # list of attributes 
---@field objnum number # the referenced *PDF* object number 
---
---# `pdf_annot`
---
--- field          type    explanation 
---
---@field attr node # list of attributes 
---@field width number # the width (not used in calculations) 
---@field height number # the height (not used in calculations) 
---@field depth number # the depth (not used in calculations) 
---@field objnum number # the referenced *PDF* object number 
---@field data string # the annotation data 
---
---# `pdf_start_link`
---
--- field             type    explanation 
---
---@field attr node # list of attributes 
---@field width number # the width (not used in calculations) 
---@field height number # the height (not used in calculations) 
---@field depth number # the depth (not used in calculations) 
---@field objnum number # the referenced *PDF* object number 
---@field link_attr table # the link attribute token list 
---@field action node # the action to perform 
---
---# `pdf_end_link`
---
--- field        type  explanation 
---
---@field attr node # 
---
---# `pdf_dest`
---
--- field               type      explanation 
---
---@field attr node # list of attributes 
---@field width number # the width (not used in calculations) 
---@field height number # the height (not used in calculations) 
---@field depth number # the depth (not used in calculations) 
---@field named_id number # is the `dest_id` a string value? 
---@field dest_id number # the destination id  string    the destination name 
---@field dest_type number # type of destination 
---@field xyz_zoom number # the zoom factor (times 1000) 
---@field objnum number # the *PDF* object number; for structure references the *PDF* object number of the linked structure element 
---
---# `pdf_action`
---
---These are a special kind of items that only appear inside *PDF* start link
---objects.
---
--- field               type              explanation 
---
---@field action_type number # the kind of action involved 
---@field action_id number # or string  token list reference or string 
---%NC `named_id`     number            the index of the destination 
---% a strange key but needed for latex; a probably downward incompable patch instead of a fix
---@field named_id`     number            are `dest_id` and `struct_id string # values? 
---@field file string # the target filename 
---@field new_window number # the window state of the target 
---@field data string # the name of the destination 
---% needed for latex and therefore equivalent to pdftex
--- `struct_id`    nil               the action does not reference a structure destination  number            id of the referenced structure destination  string            name of the referenced structure destination 
---
---Valid action types are:
---
--- value  meaning       
---
--- 0      `page`   
--- 1      `goto`   
--- 2      `thread` 
--- 3      `user`   
---
---Valid window types are:
---
--- value  meaning       
---
--- 0      `notset` 
--- 1      `new`    
--- 2      `nonew`  
---
---# `pdf_thread`
---
--- field               type    explanation 
---
---@field attr node # list of attributes 
---@field width number # the width (not used in calculations) 
---@field height number # the height (not used in calculations) 
---@field depth number # the depth (not used in calculations) 
---@field named_id number # is `tread_id` a string value? 
---@field tread_id number # the thread id  string  the thread name 
---@field thread_attr number # extra thread information 
---
---# `pdf_start_thread`
---
--- field               type    explanation 
---
---@field attr node # list of attributes 
---@field width number # the width (not used in calculations) 
---@field height number # the height (not used in calculations) 
---@field depth number # the depth (not used in calculations) 
---@field named_id number # is `tread_id` a string value? 
---@field tread_id number # the thread id  string  the thread name 
---@field thread_attr number # extra thread information 
---
---# `pdf_end_thread`
---
--- field        type  explanation 
---
---@field attr node # 
---
---# `pdf_colorstack`
---
--- field           type    explanation 
---
---@field attr node # list of attributes 
---@field stack number # colorstack id number 
---@field command number # command to execute 
---@field data string # data 
---
---# `pdf_setmatrix`
---
--- field        type    explanation 
---
---@field attr node # list of attributes 
---@field data string # data 
---
---# `pdf_save`
---
--- field        type  explanation 
---
---@field attr node # list of attributes 
---
---# `pdf_restore`
---
--- field        type  explanation 
---
---@field attr node # list of attributes 
---
----------------------------------------------------------------


---
---# The `node` library[library=node]
---
---\subsection {Introduction}
---
---The `node` library contains functions that facilitate dealing with (lists
---of) nodes and their values. They allow you to create, alter, copy, delete, and
---insert *LuaTeX* node objects, the core objects within the typesetter.
---
---*LuaTeX* nodes are represented in *Lua* as userdata with the metadata type
---`luatex.node`. The various parts within a node can be accessed using
---named fields.
---
---Each node has at least the three fields `next`, `id`, and `subtype`:
---
---* The `next` field returns the userdata object for the next node in a
---    linked list of nodes, or `nil`, if there is no next node.
---
---* The `id` indicates *TeX*'s “node type”. The field `id` has a
---    numeric value for efficiency reasons, but some of the library functions also
---    accept a string value instead of `id`.
---
---* The `subtype` is another number. It often gives further information
---    about a node of a particular `id`, but it is most important when
---    dealing with “whatsits”, because they are differentiated solely based
---    on their `subtype`.
---
---The other available fields depend on the `id` (and for “whatsits”,
---the `subtype`) of the node.
---
---Support for `unset` (alignment) nodes is partial: they can be queried and
---modified from *Lua* code, but not created.
---
---Nodes can be compared to each other, but: you are actually comparing indices into
---the node memory. This means that equality tests can only be trusted under very
---limited conditions. It will not work correctly in any situation where one of the
---two nodes has been freed and/or reallocated: in that case, there will be false
---positives.
---
---At the moment, memory management of nodes should still be done explicitly by the
---user. Nodes are not “seen” by the *Lua* garbage collector, so you have to
---call the node freeing functions yourself when you are no longer in need of a node
---(list). Nodes form linked lists without reference counting, so you have to be
---careful that when control returns back to *LuaTeX* itself, you have not deleted
---nodes that are still referenced from a `next` pointer elsewhere, and that
---you did not create nodes that are referenced more than once. Normally the setters
---and getters handle this for you.
---
---There are statistics available with regards to the allocated node memory, which
---can be handy for tracing.
---
---# `is_node`
---
---```
---<boolean|integer> t =
---    node.is_node(<any> item)
---```
---
---This function returns a number (the internal index of the node) if the argument
---is a userdata object of type `<node>` and false when no node is passed.
---
---# `types` and `whatsits`
---
---This function returns an array that maps node id numbers to node type strings,
---providing an overview of the possible top-level `id` types.
---
---```
---<table> t =
---    node.types()
---```
---
---*TeX*'s “whatsits” all have the same `id`. The various subtypes are
---defined by their `subtype` fields. The function is much like `types`,
---except that it provides an array of `subtype` mappings.
---
---```
---<table> t =
---    node.whatsits()
---```
---
---# `id`
---
---This converts a single type name to its internal numeric representation.
---
---```
---<number> id =
---    node.id(<string> type)
---```
---
---# `type` and `subtype`
---
---If the argument is a number, then the next function converts an internal numeric
---representation to an external string representation. Otherwise, it will return
---the string `node` if the object represents a node, and `nil`
---otherwise.
---
---```
---<string> type =
---    node.type(<any> n)
---```
---
---This next one converts a single whatsit name to its internal numeric
---representation (`subtype`).
---
---```
---<number> subtype =
---    node.subtype(<string> type)
---```
---
---# `fields`
---
---This function returns an array of valid field names for a particular type of
---node. If you want to get the valid fields for a “whatsit”, you have to
---supply the second argument also. In other cases, any given second argument will
---be silently ignored.
---
---```
---<table> t =
---    node.fields(<number> id)
---<table> t =
---    node.fields(<number> id, <number> subtype)
---```
---
---The function accepts string `id` and `subtype` values as well.
---
---# `has_field`
---
---This function returns a boolean that is only true if `n` is
---actually a node, and it has the field.
---
---```
---<boolean> t =
---    node.has_field(<node> n, <string> field)
---```
---
---# `new`
---
---The `new` function creates a new node. All its fields are initialized to
---either zero or `nil` except for `id` and `subtype`. Instead of
---numbers you can also use strings (names). If you create a new `whatsit` node
---the second argument is required. As with all node functions, this function
---creates a node at the *TeX* level.
---
---```
---<node> n =
---    node.new(<number> id)
---<node> n =
---    node.new(<number> id, <number> subtype)
---```
---
---# `free`, `flush_node` and `flush_list`
---
---The next one removes the node `n` from *TeX*'s memory. Be careful: no checks are
---done on whether this node is still pointed to from a register or some `next` field: it is up to you to make sure that the internal data structures
---remain correct.
---
---```
---<node> next =
---    node.free(<node> n)
---flush_node(<node> n)
---```
---
---The `free` function returns the next field of the freed node, while the
---`flush_node` alternative returns nothing.
---
---A list starting with node `n` can be flushed from *TeX*'s memory too. Be
---careful: no checks are done on whether any of these nodes is still pointed to
---from a register or some `next` field: it is up to you to make sure that the
---internal data structures remain correct.
---
---```
---node.flush_list(<node> n)
---```
---
---# `copy` and `copy_list`
---
---This creates a deep copy of node `n`, including all nested lists as in the case
---of a hlist or vlist node. Only the `next` field is not copied.
---
---```
---<node> m =
---    node.copy(<node> n)
---```
---
---A deep copy of the node list that starts at `n` can be created too. If
---`m` is also given, the copy stops just before node `m`.
---
---```
---<node> m =
---    node.copy_list(<node> n)
---<node> m =
---    node.copy_list(<node> n, <node> m)
---```
---
---Note that you cannot copy attribute lists this way. However, there is normally no
---need to copy attribute lists as when you do assignments to the `attr` field
---or make changes to specific attributes, the needed copying and freeing takes
---place automatically.
---
---# `prev` and `next`
---
---These returns the node preceding or following the given node, or `nil` if
---there is no such node.
---
---```
---<node> m =
---    node.next(<node> n)
---<node> m =
---    node.prev(<node> n)
---```
---
---# `current_attr`
---
---This returns the currently active list of attributes, if there is one.
---
---```
---<node> m =
---    node.current_attr()
---```
---
---The intended usage of `current_attr` is as follows:
---
---```
---local x1 = node.new("glyph")
---x1.attr = node.current_attr()
---local x2 = node.new("glyph")
---x2.attr = node.current_attr()
---```
---
---or:
---
---```
---local x1 = node.new("glyph")
---local x2 = node.new("glyph")
---local ca = node.current_attr()
---x1.attr = ca
---x2.attr = ca
---```
---
---The attribute lists are ref counted and the assignment takes care of incrementing
---the refcount. You cannot expect the value `ca` to be valid any more when
---you assign attributes (using `tex.setattribute`) or when control has been
---passed back to *TeX*.
---
---Note: this function is somewhat experimental, and it returns the {\it actual}
---attribute list, not a copy thereof. Therefore, changing any of the attributes in
---the list will change these values for all nodes that have the current attribute
---list assigned to them.
---
---# `hpack`
---
---This function creates a new hlist by packaging the list that begins at node `n` into a horizontal box. With only a single argument, this box is created using
---the natural width of its components. In the three argument form, `info`
---must be either `additional` or `exactly`, and `w` is the
---additional (`\hbox spread`) or exact (`\hbox to`) width to be used.
---The second return value is the badness of the generated box.
---
---```
---<node> h, <number> b =
---    node.hpack(<node> n)
---<node> h, <number> b =
---    node.hpack(<node> n, <number> w, <string> info)
---<node> h, <number> b =
---    node.hpack(<node> n, <number> w, <string> info, <string> dir)
---```
---
---Caveat: there can be unexpected side-effects to this function, like updating
---some of the `marks` and `\inserts`. Also note that the content of
---`h` is the original node list `n`: if you call `node.free(h)`
---you will also free the node list itself, unless you explicitly set the `list` field to `nil` beforehand. And in a similar way, calling `node.free(n)` will invalidate `h` as well!
---
---# `vpack`
---
---This function creates a new vlist by packaging the list that begins at node `n` into a vertical box. With only a single argument, this box is created using
---the natural height of its components. In the three argument form, `info`
---must be either `additional` or `exactly`, and `w` is the
---additional (`\vbox spread`) or exact (`\vbox to`) height to be used.
---
---```
---<node> h, <number> b =
---    node.vpack(<node> n)
---<node> h, <number> b =
---    node.vpack(<node> n, <number> w, <string> info)
---<node> h, <number> b =
---    node.vpack(<node> n, <number> w, <string> info, <string> dir)
---```
---
---The second return value is the badness of the generated box. See the description
---of `hpack` for a few memory allocation caveats.
---
---# `prepend_prevdepth`
---
---This function is somewhat special in the sense that it is an experimental helper
---that adds the interlinespace to a line keeping the baselineskip and lineskip into
---account.
---
---```
---<node> n, <number> delta =
---    node.prepend_prevdepth(<node> n,<number> prevdepth)
---```
---
---# `dimensions` and `rangedimensions`
---
---```
---<number> w, <number> h, <number> d  =
---    node.dimensions(<node> n)
---<number> w, <number> h, <number> d  =
---    node.dimensions(<node> n, <string> dir)
---<number> w, <number> h, <number> d  =
---    node.dimensions(<node> n, <node> t)
---<number> w, <number> h, <number> d  =
---    node.dimensions(<node> n, <node> t, <string> dir)
---```
---
---This function calculates the natural in-line dimensions of the node list starting
---at node `n` and terminating just before node `t` (or the end of the
---list, if there is no second argument). The return values are scaled points. An
---alternative format that starts with glue parameters as the first three arguments
---is also possible:
---
---```
---<number> w, <number> h, <number> d  =
---    node.dimensions(<number> glue_set, <number> glue_sign, <number> glue_order,
---        <node> n)
---<number> w, <number> h, <number> d  =
---    node.dimensions(<number> glue_set, <number> glue_sign, <number> glue_order,
---        <node> n, <string> dir)
---<number> w, <number> h, <number> d  =
---    node.dimensions(<number> glue_set, <number> glue_sign, <number> glue_order,
---        <node> n, <node> t)
---<number> w, <number> h, <number> d  =
---    node.dimensions(<number> glue_set, <number> glue_sign, <number> glue_order,
---        <node> n, <node> t, <string> dir)
---```
---
---This calling method takes glue settings into account and is especially useful for
---finding the actual width of a sublist of nodes that are already boxed, for
---example in code like this, which prints the width of the space in between the
---`a` and `b` as it would be if `\box0` was used as-is:
---
---```
---\setbox0 = \hbox to 20pt {a b}
---
---\directlua{print (node.dimensions(
---    tex.box[0].glue_set,
---    tex.box[0].glue_sign,
---    tex.box[0].glue_order,
---    tex.box[0].head.next,
---    node.tail(tex.box[0].head)
---)) }
---```
---
---You need to keep in mind that this is one of the few places in *TeX* where floats
---are used, which means that you can get small differences in rounding when you
---compare the width reported by `hpack` with `dimensions`.
---
---The second alternative saves a few lookups and can be more convenient in some
---cases:
---
---```
---<number> w, <number> h, <number> d  =
---    node.rangedimensions(<node> parent, <node> first)
---<number> w, <number> h, <number> d  =
---    node.rangedimensions(<node> parent, <node> first, <node> last)
---```
---
---# `mlist_to_hlist`
---
---```
---<node> h =
---    node.mlist_to_hlist(<node> n, <string> display_type, <boolean> penalties)
---```
---
---This runs the internal mlist to hlist conversion, converting the math list in
---`n` into the horizontal list `h`. The interface is exactly the same
---as for the callback `mlist_to_hlist`.
---
---# `slide`
---
---```
---<node> m =
---    node.slide(<node> n)
---```
---
---Returns the last node of the node list that starts at `n`. As a
---side-effect, it also creates a reverse chain of `prev` pointers between
---nodes.
---
---# `tail`
---
---```
---<node> m =
---    node.tail(<node> n)
---```
---
---Returns the last node of the node list that starts at `n`.
---
---# `length` and type {count}
---
---```
---<number> i =
---    node.length(<node> n)
---<number> i =
---    node.length(<node> n, <node> m)
---```
---
---Returns the number of nodes contained in the node list that starts at `n`.
---If `m` is also supplied it stops at `m` instead of at the end of the
---list. The node `m` is not counted.
---
---```
---<number> i =
---    node.count(<number> id, <node> n)
---<number> i =
---    node.count(<number> id, <node> n, <node> m)
---```
---
---Returns the number of nodes contained in the node list that starts at `n`
---that have a matching `id` field. If `m` is also supplied, counting
---stops at `m` instead of at the end of the list. The node `m` is not
---counted. This function also accept string `id`'s.
---
---# `is_char` and `is_glyph`
---
---The subtype of a glyph node signals if the glyph is already turned into a character reference
---or not.
---
---```
---<boolean> b =
---    node.is_char(<node> n)
---<boolean> b =
---    node.is_glyph(<node> n)
---```
---
---# `traverse`
---
---```
---<node> t, id, subtype =
---    node.traverse(<node> n)
---```
---
---This is a *Lua* iterator that loops over the node list that starts at `n`.
---Typically code looks like this:
---
---```
---for n in node.traverse(head) do
---   ...
---end
---```
---
---is functionally equivalent to:
---
---```
---do
---  local n
---  local function f (head,var)
---    local t
---    if var == nil then
---       t = head
---    else
---       t = var.next
---    end
---    return t
---  end
---  while true do
---    n = f (head, n)
---    if n == nil then break end
---    ...
---  end
---end
---```
---
---It should be clear from the definition of the function `f` that even though
---it is possible to add or remove nodes from the node list while traversing, you
---have to take great care to make sure all the `next` (and `prev`)
---pointers remain valid.
---
---If the above is unclear to you, see the section “For Statement” in the
---*Lua* Reference Manual.
---
---# `traverse_id`
---
---```
---<node> t, subtype =
---    node.traverse_id(<number> id, <node> n)
---```
---
---This is an iterator that loops over all the nodes in the list that starts at
---`n` that have a matching `id` field.
---
---See the previous section for details. The change is in the local function `f`, which now does an extra while loop checking against the upvalue `id`:
---
---```
--- local function f(head,var)
---   local t
---   if var == nil then
---      t = head
---   else
---      t = var.next
---   end
---   while not t.id == id do
---      t = t.next
---   end
---   return t
--- end
---```
---
---# `traverse_char` and `traverse_glyph`
---
---The `traverse_char` iterator loops over the `glyph` nodes in a list.
---Only nodes with a subtype less than 256 are seen.
---
---```
---<node> n, char, font =
---    node.traverse_char(<node> n)
---```
---
---The `traverse_glyph` iterator loops over a list and returns the list and
---filters all glyphs:
---
---```
---<node> n, char, font =
---    node.traverse_glyph(<node> n)
---```
---
---# `traverse_list`
---
---This iterator loops over the `hlist` and `vlist` nodes in a list.
---
---```
---<node> n, id, subtype, list =
---    node.traverse_list(<node> n)
---```
---
---The four return values can save some time compared to fetching these fields but
---in practice you seldom need them all. So consider it a (side effect of
---experimental) convenience.
---
---# `has_glyph`
---
---This function returns the first glyph or disc node in the given list:
---
---```
---<node> n =
---    node.has_glyph(<node> n)
---```
---
---# `end_of_math`
---
---```
---<node> t =
---    node.end_of_math(<node> start)
---```
---
---Looks for and returns the next `math_node` following the `start`. If
---the given node is a math end node this helper returns that node, else it follows
---the list and returns the next math endnote. If no such node is found nil is
---returned.
---
---# `remove`
---
---```
---<node> head, current =
---    node.remove(<node> head, <node> current)
---```
---
---This function removes the node `current` from the list following `head`. It is your responsibility to make sure it is really part of that list.
---The return values are the new `head` and `current` nodes. The
---returned `current` is the node following the `current` in the calling
---argument, and is only passed back as a convenience (or `nil`, if there is
---no such node). The returned `head` is more important, because if the
---function is called with `current` equal to `head`, it will be
---changed.
---
---# `insert_before`
---
---```
---<node> head, new =
---    node.insert_before(<node> head, <node> current, <node> new)
---```
---
---This function inserts the node `new` before `current` into the list
---following `head`. It is your responsibility to make sure that `current` is really part of that list. The return values are the (potentially
---mutated) `head` and the node `new`, set up to be part of the list
---(with correct `next` field). If `head` is initially `nil`, it
---will become `new`.
---
---# `insert_after`
---
---```
---<node> head, new =
---    node.insert_after(<node> head, <node> current, <node> new)
---```
---
---This function inserts the node `new` after `current` into the list
---following `head`. It is your responsibility to make sure that `current` is really part of that list. The return values are the `head` and
---the node `new`, set up to be part of the list (with correct `next`
---field). If `head` is initially `nil`, it will become `new`.
---
---# `first_glyph`
---
---```
---<node> n =
---    node.first_glyph(<node> n)
---<node> n =
---    node.first_glyph(<node> n, <node> m)
---```
---
---Returns the first node in the list starting at `n` that is a glyph node
---with a subtype indicating it is a glyph, or `nil`. If `m` is given,
---processing stops at (but including) that node, otherwise processing stops at the
---end of the list.
---
---# `ligaturing`
---
---```
---<node> h, <node> t, <boolean> success =
---    node.ligaturing(<node> n)
---<node> h, <node> t, <boolean> success =
---    node.ligaturing(<node> n, <node> m)
---```
---
---Apply *TeX*-style ligaturing to the specified nodelist. The tail node `m` is
---optional. The two returned nodes `h` and `t` are the new head and
---tail (both `n` and `m` can change into a new ligature).
---
---# `kerning`
---
---```
---<node> h, <node> t, <boolean> success =
---    node.kerning(<node> n)
---<node> h, <node> t, <boolean> success =
---    node.kerning(<node> n, <node> m)
---```
---
---Apply *TeX*-style kerning to the specified node list. The tail node `m` is
---optional. The two returned nodes `h` and `t` are the head and tail
---(either one of these can be an inserted kern node, because special kernings with
---word boundaries are possible).
---
---# `unprotect_glyph[s]`
---
---```
---node.unprotect_glyph(<node> n)
---node.unprotect_glyphs(<node> n,[<node> ,m])
---```
---
---Subtracts 256 from all glyph node subtypes. This and the next function are
---helpers to convert from `characters` to `glyphs` during node
---processing. The second argument is optional and indicates the end of a range.
---
---# `protect_glyph[s]`
---
---```
---node.protect_glyph(<node> n)
---node.protect_glyphs(<node> n,[<node> m])
---```
---
---Adds 256 to all glyph node subtypes in the node list starting at `n`,
---except that if the value is 1, it adds only 255. The special handling of 1 means
---that `characters` will become `glyphs` after subtraction of 256. A
---single character can be marked by the singular call. The second argument is
---optional and indicates the end of a range.
---
---# `last_node`
---
---```
---<node> n =
---    node.last_node()
---```
---
---This function pops the last node from *TeX*'s “current list”. It returns
---that node, or `nil` if the current list is empty.
---
---# `write`
---
---```
---node.write(<node> n)
---```
---
---This function that will append a node list to *TeX*'s “current list”. The
---node list is not deep-copied! There is no error checking either! You mignt need
---to enforce horizontal mode in order for this to work as expected.
---
---# `protrusion_skippable`
---
---```
---<boolean> skippable =
---    node.protrusion_skippable(<node> n)
---```
---
---Returns `true` if, for the purpose of line boundary discovery when
---character protrusion is active, this node can be skipped.
---
----------------------------------------------------------------


---
---# Glue handling[library=node]
---
---# `setglue`
---
---You can set the five properties of a glue in one go. Non-numeric values are
---equivalent to zero and reset a property.
---
---```
---node.setglue(<node> n)
---node.setglue(<node> n,width,stretch,shrink,stretch_order,shrink_order)
---```
---
---When you pass values, only arguments that are numbers are assigned so
---
---```
---node.setglue(n,655360,false,65536)
---```
---
---will only adapt the width and shrink.
---
---When a list node is passed, you set the glue, order and sign instead.
---
---# `getglue`
---
---The next call will return 5 values or nothing when no glue is passed.
---
---```
---<integer> width, <integer> stretch, <integer> shrink, <integer> stretch_order,
---    <integer> shrink_order = node.getglue(<node> n)
---```
---
---When the second argument is false, only the width is returned (this is consistent
---with `tex.get`).
---
---When a list node is passed, you get back the glue that is set, the order of that
---glue and the sign.
---
---# `is_zero_glue`
---
---This function returns `true` when the width, stretch and shrink properties
---are zero.
---
---```
---<boolean> isglue =
---    node.is_zero_glue(<node> n)
---```
---
----------------------------------------------------------------


---
---# Attribute handling[library=node]
---
---# Attributes
---
---The newly introduced attribute registers are non-trivial, because the value
---that is attached to a node is essentially a sparse array of key-value pairs. It
---is generally easiest to deal with attribute lists and attributes by using the
---dedicated functions in the `node` library, but for completeness, here is
---the low-level interface.
---
---Attributes appear as linked list of userdata objects in the `attr` field of
---individual nodes. They can be handled individually, but it is much safer and more
---efficient to use the dedicated functions associated with them.
---
---# `attribute_list` nodes
---
---An `attribute_list` item is used as a head pointer for a list of attribute
---items. It has only one user-visible field:
---
--- field        type  explanation 
---
---@field next node # pointer to the first attribute 
---
---# `attr` nodes
---
---A normal node's attribute field will point to an item of type `attribute_list`, and the `next` field in that item will point to the first
---defined “attribute” item, whose `next` will point to the second
---“attribute” item, etc.
---
--- field          type    explanation 
---
---@field next node # pointer to the next attribute 
---@field number number # the attribute type id 
---@field value number # the attribute value 
---
---As mentioned it's better to use the official helpers rather than edit these
---fields directly. For instance the `prev` field is used for other purposes
---and there is no double linked list.
---
---# `has_attribute`
---
---```
---<number> v =
---    node.has_attribute(<node> n, <number> id)
---<number> v =
---    node.has_attribute(<node> n, <number> id, <number> val)
---```
---
---Tests if a node has the attribute with number `id` set. If `val` is
---also supplied, also tests if the value matches `val`. It returns the value,
---or, if no match is found, `nil`.
---
---# `get_attribute`
---
---```
---<number> v =
---    node.get_attribute(<node> n, <number> id)
---```
---
---Tests if a node has an attribute with number `id` set. It returns the
---value, or, if no match is found, `nil`. If no `id` is given then the
---zero attributes is assumed.
---
---# `find_attribute`
---
---```
---<number> v, <node> n =
---    node.find_attribute(<node> n, <number> id)
---```
---
---Finds the first node that has attribute with number `id` set. It returns
---the value and the node if there is a match and otherwise nothing.
---
---# `set_attribute`
---
---```
---node.set_attribute(<node> n, <number> id, <number> val)
---```
---
---Sets the attribute with number `id` to the value `val`. Duplicate
---assignments are ignored.
---
---# `unset_attribute`
---
---```
---<number> v =
---    node.unset_attribute(<node> n, <number> id)
---<number> v =
---    node.unset_attribute(<node> n, <number> id, <number> val)
---```
---
---Unsets the attribute with number `id`. If `val` is also supplied, it
---will only perform this operation if the value matches `val`. Missing
---attributes or attribute-value pairs are ignored.
---
---If the attribute was actually deleted, returns its old value. Otherwise, returns
---`nil`.
---
---# `slide`
---
---This helper makes sure that the node lists is double linked and returns the found
---tail node.
---
---```
---<node> tail =
---    node.slide(<node> n)
---```
---
---After some callbacks automatic sliding takes place. This feature can be turned
---off with `node.fix_node_lists(false)` but you better make sure then that
---you don't mess up lists. In most cases *TeX* itself only uses `next`
---pointers but your other callbacks might expect proper `prev` pointers too.
---Future versions of *LuaTeX* can add more checking but this will not influence
---usage.
---
---# `check_discretionary`, `check_discretionaries`
---
---When you fool around with disc nodes you need to be aware of the fact that they
---have a special internal data structure. As long as you reassign the fields when
---you have extended the lists it's ok because then the tail pointers get updated,
---but when you add to list without reassigning you might end up in trouble when
---the linebreak routine kicks in. You can call this function to check the list for
---issues with disc nodes.
---
---```
---node.check_discretionary(<node> n)
---node.check_discretionaries(<node> head)
---```
---
---The plural variant runs over all disc nodes in a list, the singular variant
---checks one node only (it also checks if the node is a disc node).
---
---# `flatten_discretionaries`
---
---This function will remove the discretionaries in the list and inject the replace
---field when set.
---
---```
---<node> head, count = node.flatten_discretionaries(<node> n)
---```
---
---# `family_font`
---
---When you pass a proper family identifier the next helper will return the font
---currently associated with it. You can normally also access the font with the
---normal font field or getter because it will resolve the family automatically for
---noads.
---
---```
---<integer> id =
---    node.family_font(<integer> fam)
---```
---
----------------------------------------------------------------


---
---# Two access models[library=node]
---
---Deep down in *TeX* a node has a number which is a numeric entry in a memory
---table. In fact, this model, where *TeX* manages memory is real fast and one of
---the reasons why plugging in callbacks that operate on nodes is quite fast too.
---Each node gets a number that is in fact an index in the memory table and that
---number often is reported when you print node related information. You go from
---userdata nodes and there numeric references and back with:
---
---```
---<integer> d = node.direct.todirect(<node> n))
---<node> n = node.direct.tonode(<integer> d))
---```
---
---The userdata model is rather robust as it is a virtual interface with some
---additional checking while the more direct access which uses the node numbers
---directly. However, even with userdata you can get into troubles when you free
---nodes that are no longer allocated or mess up lists. if you apply `tostring` to a node you see its internal (direct) number and id.
---
---The first model provides key based access while the second always accesses fields
---via functions:
---
---```
---nodeobject.char
---getfield(nodenumber,"char")
---```
---
---If you use the direct model, even if you know that you deal with numbers, you
---should not depend on that property but treat it as an abstraction just like
---traditional nodes. In fact, the fact that we use a simple basic datatype has the
---penalty that less checking can be done, but less checking is also the reason why
---it's somewhat faster. An important aspect is that one cannot mix both methods,
---but you can cast both models. So, multiplying a node number makes no sense.
---
---So our advice is: use the indexed (table) approach when possible and investigate
---the direct one when speed might be a real issue. For that reason *LuaTeX* also
---provide the `get*` and `set*` functions in the top level node
---namespace. There is a limited set of getters. When implementing this direct
---approach the regular index by key variant was also optimized, so direct access
---only makes sense when nodes are accessed millions of times (which happens in some
---font processing for instance).
---
---We're talking mostly of getters because setters are less important. Documents
---have not that many content related nodes and setting many thousands of properties
---is hardly a burden contrary to millions of consultations.
---
---Normally you will access nodes like this:
---
---```
---local next = current.next
---if next then
---    -- do something
---end
---```
---
---Here `next` is not a real field, but a virtual one. Accessing it results in
---a metatable method being called. In practice it boils down to looking up the node
---type and based on the node type checking for the field name. In a worst case you
---have a node type that sits at the end of the lookup list and a field that is last
---in the lookup chain. However, in successive versions of *LuaTeX* these lookups
---have been optimized and the most frequently accessed nodes and fields have a
---higher priority.
---
---Because in practice the `next` accessor results in a function call, there
---is some overhead involved. The next code does the same and performs a tiny bit
---faster (but not that much because it is still a function call but one that knows
---what to look up).
---
---```
---local next = node.next(current)
---if next then
---    -- do something
---end
---```
---
---Some accessors are used frequently and for these we provide more efficient helpers:
---
--- function           explanation 
---
--- `getnext`     parsing nodelist always involves this one 
--- `getprev`     used less but a logical companion to `getnext` 
---@field getboth returns the next and prev pointer of a node # 
--- `getid`       consulted a lot 
--- `getsubtype`  consulted less but also a topper 
--- `getfont`     used a lot in *OpenType* handling (glyph nodes are consulted a lot) 
--- `getchar`     idem and also in other places 
--- `getwhd`      returns the `width`, `height` and `depth` of a list, rule or (unexpanded) glyph as well as glue (its spec is looked at) and unset nodes
--- `getdisc`     returns the `pre`, `post` and `replace` fields and optionally when true is passed also the tail fields 
--- `getlist`     we often parse nested lists so this is a convenient one too 
--- `getleader`   comparable to list, seldom used in *TeX* (but needs frequent consulting like lists; leaders could have been made a dedicated node type) 
--- `getfield`    generic getter, sufficient for the rest (other field names are often shared so a specific getter makes no sense then) 
--- `getbox`      gets the given box (a list node) 
--- `getoffsets`  gets the `xoffset` and `yoffset` of a glyph or `left` and `right` values of a rule 
---
---In the direct namespace there are more such helpers and most of them are
---accompanied by setters. The getters and setters are clever enough to see what
---node is meant. We don't deal with whatsit nodes: their fields are always accessed
---by name. It doesn't make sense to add getters for all fields, we just identifier
---the most likely candidates. In complex documents, many node and fields types
---never get seen, or seen only a few times, but for instance glyphs are candidates
---for such optimization. The `node.direct` interface has some more helpers.
---\footnote {We can define the helpers in the node namespace with `getfield`
---which is about as efficient, so at some point we might provide that as module.}
---
---The `setdisc` helper takes three (optional) arguments plus an optional
---fourth indicating the subtype. Its `getdisc` takes an optional boolean;
---when its value is `true` the tail nodes will also be returned. The `setfont` helper takes an optional second argument, it being the character. The
---directmode setter `setlink` takes a list of nodes and will link them,
---thereby ignoring `nil` entries. The first valid node is returned (beware:
---for good reason it assumes single nodes). For rarely used fields no helpers are
---provided and there are a few that probably are used seldom too but were added for
---consistency. You can of course always define additional accessors using `getfield` and `setfield` with little overhead. When the second argument of
---`setattributelist` is `true` the current attribute list is assumed.
---
---\def\yes{`+`} \def\nop{`-$}
---
---\def\supported#1#2#3%
--- { `#1`
---   \ifx#2\yes\lix{node}       {#1}\fi #2
---   \ifx#3\yes\lix{node.direct}{#1}\fi #3 
---  \NR}
---
--- function  node  direct 
---
---\supported {check_discretionaries}   \yes \yes
---\supported {check_discretionary}     \yes \yes
---\supported {copy_list}               \yes \yes
---\supported {copy}                    \yes \yes
---\supported {count}                   \yes \yes
---\supported {current_attr}            \yes \yes
---\supported {dimensions}              \yes \yes
---\supported {effective_glue}          \yes \yes
---\supported {end_of_math}             \yes \yes
---\supported {family_font}             \yes \nop
---\supported {fields}                  \yes \nop
---\supported {find_attribute}          \yes \yes
---\supported {first_glyph}             \yes \yes
---\supported {fix_node_lists}          \yes \nop
---\supported {flatten_discretionaries} \yes \yes
---\supported {flush_list}              \yes \yes
---\supported {flush_node}              \yes \yes
---\supported {flush_properties_table}  \yes \yes
---\supported {free}                    \yes \yes
---\supported {get_attribute}           \yes \yes
---\supported {get_properties_table}    \yes \yes
---\supported {get_synctex_fields}      \nop \yes
---\supported {getattributelist}        \nop \yes
---\supported {getboth}                 \yes \yes
---\supported {getbox}                  \nop \yes
---\supported {getchar}                 \yes \yes
---\supported {getcomponents}           \nop \yes
---\supported {getdata}                 \nop \yes
---\supported {getdepth}                \nop \yes
---\supported {getdirection}            \nop \yes
---\supported {getdir}                  \nop \yes
---\supported {getdisc}                 \yes \yes
---\supported {getexpansion}            \nop \yes
---\supported {getfam}                  \nop \yes
---\supported {getfield}                \yes \yes
---\supported {getfont}                 \yes \yes
---\supported {getglue}                 \yes \yes
---\supported {getheight}               \nop \yes
---\supported {getid}                   \yes \yes
---\supported {getkern}                 \nop \yes
---\supported {getlang}                 \nop \yes
---\supported {getleader}               \yes \yes
---\supported {getlist}                 \yes \yes
---\supported {getnext}                 \yes \yes
---\supported {getnucleus}              \nop \yes
---\supported {getoffsets}              \nop \yes
---\supported {getpenalty}              \nop \yes
---\supported {getprev}                 \yes \yes
---\supported {getproperty}             \yes \yes
---\supported {getshift}                \nop \yes
---\supported {getsubtype}              \yes \yes
---\supported {getsub}                  \nop \yes
---\supported {getsup}                  \nop \yes
---\supported {getwhd}                  \yes \yes
---\supported {getwidth}                \nop \yes
---\supported {has_attribute}           \yes \yes
---\supported {has_field}               \yes \yes
---\supported {has_glyph}               \yes \yes
---\supported {hpack}                   \yes \yes
---\supported {hyphenating}             \nop \yes
---\supported {id}                      \yes \nop
---\supported {insert_after}            \yes \yes
---\supported {insert_before}           \yes \yes
---\supported {is_char}                 \yes \yes
---\supported {is_direct}               \nop \yes
---\supported {is_glyph}                \yes \yes
---\supported {is_node}                 \yes \yes
---\supported {is_zero_glue}            \yes \yes
---\supported {kerning}                 \yes \yes
---\supported {last_node}               \yes \yes
---\supported {length}                  \yes \yes
---\supported {ligaturing}              \yes \yes
---\supported {make_extensible}         \yes \nop
---\supported {mlist_to_hlist}          \yes \nop
---\supported {new}                     \yes \yes
---\supported {next}                    \yes \nop
---\supported {prepend_prevdepth}       \yes \yes
---\supported {prev}                    \yes \nop
---\supported {protect_glyphs}          \yes \yes
---\supported {protect_glyph}           \yes \yes
---\supported {protrusion_skippable}    \yes \yes
---\supported {rangedimensions}         \yes \yes
---\supported {remove}                  \yes \yes
---\supported {set_attribute}           \yes \yes
---\supported {set_properties_mode}     \yes \yes
---\supported {set_synctex_fields}      \nop \yes
---\supported {setattributelist}        \nop \yes
---\supported {setboth}                 \nop \yes
---\supported {setbox}                  \nop \yes
---\supported {setchar}                 \nop \yes
---\supported {setcomponents}           \nop \yes
---\supported {setdata}                 \nop \yes
---\supported {setdepth}                \nop \yes
---\supported {setdirection}            \nop \yes
---\supported {setdir}                  \nop \yes
---\supported {setdisc}                 \nop \yes
---\supported {setexpansion}            \nop \yes
---\supported {setfam}                  \nop \yes
---\supported {setfield}                \yes \yes
---\supported {setfont}                 \nop \yes
---\supported {setglue}                 \yes \yes
---\supported {setheight}               \nop \yes
---\supported {setkern}                 \nop \yes
---\supported {setlang}                 \nop \yes
---\supported {setleader}               \nop \yes
---\supported {setlink}                 \nop \yes
---\supported {setlist}                 \nop \yes
---\supported {setnext}                 \nop \yes
---\supported {setnucleus}              \nop \yes
---\supported {setoffsets}              \nop \yes
---\supported {setpenalty}              \nop \yes
---\supported {setprev}                 \nop \yes
---\supported {setproperty}             \yes \yes
---\supported {setshift}                \nop \yes
---\supported {setsplit}                \nop \yes
---\supported {setsubtype}              \nop \yes
---\supported {setsub}                  \nop \yes
---\supported {setsup}                  \nop \yes
---\supported {setwhd}                  \nop \yes
---\supported {setwidth}                \nop \yes
---\supported {slide}                   \yes \yes
---\supported {subtypes}                \yes \nop
---\supported {subtype}                 \yes \nop
---\supported {tail}                    \yes \yes
---\supported {todirect}                \nop \yes
---\supported {tonode}                  \nop \yes
---\supported {tostring}                \yes \yes
---\supported {traverse_char}           \yes \yes
---\supported {traverse_glyph}          \yes \yes
---\supported {traverse_id}             \yes \yes
---\supported {traverse_list}           \nop \yes
---\supported {traverse}                \yes \yes
---\supported {types}                   \yes \nop
---\supported {type}                    \yes \nop
---\supported {unprotect_glyphs}        \yes \yes
---\supported {unprotect_glyph}         \yes \yes
---\supported {unset_attribute}         \yes \yes
---\supported {usedlist}                \yes \yes
---\supported {uses_font}               \yes \yes
---\supported {values}                  \yes \nop
---\supported {vpack}                   \yes \yes
---\supported {whatsits}                \yes \nop
---\supported {write}                   \yes \yes
---
---The `node.next` and `node.prev` functions will stay but for
---consistency there are variants called `getnext` and `getprev`. We had
---to use `get` because `node.id` and `node.subtype` are already
---taken for providing meta information about nodes. Note: The getters do only basic
---checking for valid keys. You should just stick to the keys mentioned in the
---sections that describe node properties.
---
---Some of the getters and setters handle multiple node types, given that the field
---is relevant. In that case, some field names are considered similar (like `kern` and `width`, or `data` and `value`. In retrospect we
---could have normalized field names better but we decided to stick to the original
---(internal) names as much as possible. After all, at the *Lua* end one can easily
---create synonyms.
---
---In `setfield` and `getfield` specials and writes accept `data`
---and `value` as equivalent keys. In the case of a write whatsit getting the
---`value` returns the token list as table, while `data` returns the
---expansion as a string (version 1.23.2, 2026).
---
---Some nodes have indirect references. For instance a math character refers to a
---family instead of a font. In that case we provide a virtual font field as
---accessor. So, `getfont` and `.font` can be used on them. The same is
---true for the `width`, `height` and `depth` of glue nodes. These
---actually access the spec node properties, and here we can set as well as get the
---values.
---
---In some places *LuaTeX* can do a bit of extra checking for valid node lists and
---you can enable that with:
---
---```
---node.fix_node_lists(<boolean> b)
---```
---
---You can set and query the \SYNCTEX\ fields, a file number aka tag and a line
---number, for a glue, kern, hlist, vlist, rule and math nodes as well as glyph
---nodes (although this last one is not used in native \SYNCTEX).
---
---```
---node.direct.set_synctex_fields(<integer> n, <integer> f, <integer> l)
---<integer> f, <integer> l =
---    node.direct.get_synctex_fields(<integer> n)
---```
---
---Of course you need to know what you're doing as no checking on sane values takes
---place. Also, the synctex interpreter used in editors is rather peculiar and has
---some assumptions (heuristics).
---
----------------------------------------------------------------


---
---# Properties[library=node]
---
---Attributes are a convenient way to relate extra information to a node. You can
---assign them at the *TeX* end as well as at the *Lua* end and and consult them at
---the *Lua* end. One big advantage is that they obey grouping. They are linked
---lists and normally checking for them is pretty efficient, even if you use a lot
---of them. A macro package has to provide some way to manage these attributes at the
---*TeX* end because otherwise clashes in their usage can occur.
---
---Each node also can have a properties table and you can assign values to this
---table using the `setproperty` function and get properties using the `getproperty` function. Managing properties is way more demanding than managing
---attributes.
---
---Take the following example:
---
---```
---\directlua {
---    local n = node.new("glyph")
---
---    node.setproperty(n,"foo")
---    print(node.getproperty(n))
---
---    node.setproperty(n,"bar")
---    print(node.getproperty(n))
---
---    node.free(n)
---}
---```
---
---This will print `foo` and `bar` which in itself is not that useful
---when multiple mechanisms want to use this feature. A variant is:
---
---```
---\directlua {
---    local n = node.new("glyph")
---
---    node.setproperty(n,{ one = "foo", two = "bar" })
---    print(node.getproperty(n).one)
---    print(node.getproperty(n).two)
---
---    node.free(n)
---}
---```
---
---This time we store two properties with the node. It really makes sense to have a
---table as property because that way we can store more. But in order for that to
---work well you need to do it this way:
---
---```
---\directlua {
---    local n = node.new("glyph")
---
---    local t = node.getproperty(n)
---
---    if not t then
---        t = { }
---        node.setproperty(n,t)
---    end
---    t.one = "foo"
---    t.two = "bar"
---
---    print(node.getproperty(n).one)
---    print(node.getproperty(n).two)
---
---    node.free(n)
---}
---```
---
---Here our own properties will not overwrite other users properties unless of
---course they use the same keys. So, eventually you will end up with something:
---
---```
---\directlua {
---    local n = node.new("glyph")
---
---    local t = node.getproperty(n)
---
---    if not t then
---        t = { }
---        node.setproperty(n,t)
---    end
---    t.myself = { one = "foo", two = "bar" }
---
---    print(node.getproperty(n).myself.one)
---    print(node.getproperty(n).myself.two)
---
---    node.free(n)
---}
---```
---
---This assumes that only you use `myself` as subtable. The possibilities are
---endless but care is needed. For instance, the generic font handler that ships
---with *ConTeXt* uses the `injections` subtable and you should not mess with
---that one!
---
---There are a few helper functions that you normally should not touch as user: `flush_properties_table` will wipe the table (normally a bad idea), `get_properties_table` and will give the table that stores properties (using
---direct entries) and you can best not mess too much with that one either because
---*LuaTeX* itself will make sure that entries related to nodes will get wiped when
---nodes get freed, so that the *Lua* garbage collector can do its job. In fact, the
---main reason why we have this mechanism is that it saves the user (or macro
---package) some work. One can easily write a property mechanism in *Lua* where
---after a shipout properties gets cleaned up but it's not entirely trivial to make
---sure that with each freed node also its properties get freed, due to the fact
---that there can be nodes left over for a next page. And having a callback bound to
---the node deallocator would add way to much overhead.
---
---Managing properties in the node (de)allocator functions is disabled by default
---and is enabled by:
---
---```
---node.set_properties_mode(true)
---```
---
---When we copy a node list that has a table as property, there are several possibilities: we do the same as
---a new node, we copy the entry to the table in properties (a reference), we do
---a deep copy of a table in the properties, we create a new table and give it
---the original one as a metatable. After some experiments (that also included
---timing) with these scenarios we decided that a deep copy made no sense, nor
---did nilling. In the end both the shallow copy and the metatable variant were
---both ok, although the second one is slower. The most important aspect to keep
---in mind is that references to other nodes in properties no longer can be
---valid for that copy. We could use two tables (one unique and one shared) or
---metatables but that only complicates matters.
---
---When defining a new node, we could already allocate a table but it is rather easy
---to do that at the lua end e.g.\ using a metatable `__index` method. That
---way it is under macro package control. When deleting a node, we could keep the
---slot (e.g. setting it to false) but it could make memory consumption raise
---unneeded when we have temporary large node lists and after that only small lists.
---Both are not done.
---
---So in the end this is what happens now: when a node is copied, and it has a table
---as property, the new node will share that table. If the second argument of `set_properties_mode` is `true` then a metatable approach is chosen: the
---copy gets its own table with the original table as metatable. If you use the
---generic font loader the mode is enabled that way.
---
---A few more xperiments were done. For instance: copy attributes to the properties
---so that we have fast access at the *Lua* end. In the end the overhead is not
---compensated by speed and convenience, in fact, attributes are not that slow when
---it comes to accessing them. So this was rejected.
---
---Another experiment concerned a bitset in the node but again the gain compared to
---attributes was neglectable and given the small amount of available bits it also
---demands a pretty strong agreement over what bit represents what, and this is
---unlikely to succeed in the *TeX* community. It doesn't pay off.
---
---Just in case one wonders why properties make sense: it is not so much speed that
---we gain, but more convenience: storing all kind of (temporary) data in attributes
---is no fun and this mechanism makes sure that properties are cleaned up when a
---node is freed. Also, the advantage of a more or less global properties table is
---that we stay at the *Lua* end. An alternative is to store a reference in the node
---itself but that is complicated by the fact that the register has some limitations
---(no numeric keys) and we also don't want to mess with it too much.
---
----------------------------------------------------------------


---
---\stopchapter
---
---\stopcomponent
---